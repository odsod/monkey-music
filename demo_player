#!/usr/bin/env ruby

if RUBY_VERSION =~ /1.9/
  Encoding.default_external = Encoding::UTF_8
  Encoding.default_internal = Encoding::UTF_8
end

require 'yaml'

@type = $stdin.gets.chomp

if @type == "INIT"
  @cache = {}
  @cache[:width] = Integer($stdin.gets.chomp)
  @cache[:height] = Integer($stdin.gets.chomp)
  @cache[:turn_limit] = Integer($stdin.gets.chomp)
  [:top_tracks, :top_albums, :top_artists, :disliked_artists].each do |toplist|
    @cache[toplist] = []
    n = Integer($stdin.gets.chomp)
    n.times { @cache[toplist] << $stdin.gets.chomp }
  @cache[:uris] = {}
  end
  File.open(File.join(Dir.getwd, "cache_demo_player"), "w+") {|f| f.write YAML::dump(@cache)}
  exit
elsif @type == "TURN"
  @cache = YAML::load(IO.read "cache_demo_player")
  # Read indata
  @turn = Integer($stdin.gets.chomp)
  @monkey = $stdin.gets.chomp
  @remaining_capacity = Integer($stdin.gets.chomp)
  @remaining_time = Integer($stdin.gets.chomp)
  @num_responses = Integer($stdin.gets.chomp)
  @num_responses.times do
    response = $stdin.gets.chomp.split(",")
    cache[:uris][response[0]][response]
  end
  @unknown = []
  # Read level
  @tracks = []
  @cache[:height].times do |y|
    row = $stdin.gets.chomp.split(',')
    @cache[:width].times do |x|
      thing = row[x]
      if thing == @monkey
        @x, @y = x, y
      elsif /spotify:track/.match(thing)
        @unknown << thing unless @cache[:uris][thing]
        @tracks << [x, y]
      elsif thing == "U"
        @user = [x, y]
      end
    end
  end
end

#if uri = @unknown.pop
  #puts uri
  #$stdout.flush
  #n = Integer($stdin.gets.chomp)
  #if n == 1
    #@cache[:uris][uri] = $stdin.gets.chomp
  #end
  #File.open(File.join(Dir.getwd, "cache_p1"), "w+") {|f| f.write YAML::dump(@cache)}
  #exit
#end

def move_toward(x, y)
  if @x < x
    "E"
  elsif @x > x
    "W"
  elsif @y < y
    "S"
  elsif @y > y
    "N"
  end
end

def closest_track
  curr_closest = @tracks.pop()
  curr_smallest_distance = distance_to(*curr_closest)
  @tracks.each do |track|
    curr_distance = distance_to(*track)
    if curr_distance < curr_smallest_distance
      curr_closest = track
      curr_smallest_distance = curr_distance
    end
  end
  curr_closest
end

def distance_to(x, y)
  (@x - x).abs + (@y - y).abs
end

if (@remaining_capacity > 0) && (not @tracks.empty?)
  puts move_toward(*closest_track())
else
  puts move_toward(*@user)
end
